#!/usr/bin/env julia

using SHA, BinaryProvider, BinaryBuilder
import BinaryBuilder: CompilerShard

function list_targz_files(d)
    files = try
        readdir(d)
    catch
        []
    end
    return [joinpath(d, f) for f in files if length(f) > 7 && f[end-6:end] == ".tar.gz"]
end


# Collect list of .tar.gz files
targz_files = list_targz_files(@__DIR__)
if isempty(targz_files)
    append!(targz_files, list_targz_files(joinpath(@__DIR__, "Rootfs", "products")))
    #append!(targz_files, list_targz_files(joinpath(@__DIR__, "BaseCompilerShard", "products")))
    append!(targz_files, list_targz_files(joinpath(@__DIR__, "GCCBootstrap", "products")))
    append!(targz_files, list_targz_files(joinpath(@__DIR__, "LLVMBootstrap", "products")))
    append!(targz_files, list_targz_files(joinpath(@__DIR__, "PlatformSupport", "products")))
    #append!(targz_files, list_targz_files(joinpath(@__DIR__, "GCC", "products")))
    #append!(targz_files, list_targz_files(joinpath(@__DIR__, "LLVM", "products")))
end

function teeln(io::IO, args...)
    println(io, args...)
    println(args...)
end

rht_path = joinpath(dirname(pathof(BinaryBuilder)), "RootfsHashTable.jl")
rht_mtime = stat(rht_path).mtime
if isfile(rht_path)
    shard_hash_table = include(rht_path)
else
    shard_hash_table = Dict{CompilerShard,String}()
end

# Read in all new shards, add them into shard_hash_table
for fname in targz_files
    try
        name, version, platform = extract_name_version_platform_key(fname)

        # Split out target platform if we've got one.
        target = nothing
        if occursin("-", name)
            target = platform_key_abi(name[first(findfirst("-", name))+1:end])
            name = split(name, "-")[1]
        end

        # Skip any shard that was updated less recently than the hash table itself
        tar_cs = CompilerShard(name, version, platform, :targz; target=target)
        if !(tar_cs in keys(shard_hash_table)) || stat(fname).mtime >= rht_mtime
            tar_hash = open(fname, "r") do f
                bytes2hex(sha256(f))
            end
            shard_hash_table[tar_cs] = tar_hash
        end

        sname = fname[1:end-7]*".squashfs"
        squash_cs = CompilerShard(name, version, platform, :squashfs; target=target)
        if !(squash_cs in keys(shard_hash_table)) || stat(sname).mtime >= rht_mtime
            # Open up the .squashfs file and ensure it's set to UID 0, for hashing purposes.
            BinaryBuilder.rewrite_squashfs_uids(sname, 0)

            squash_hash = open(sname, "r") do f
                bytes2hex(sha256(f))
            end
            shard_hash_table[squash_cs] = squash_hash
        end
    catch
        @warn("Failed on $(fname)")
    end
end


rm(rht_path*".new"; force=true)
open(rht_path*".new", "w") do fout
    teeln(fout, "## This file auto-generated by Yggdrasil/checksum.jl")
    teeln(fout, "shard_hash_table = Dict{CompilerShard,String}(")

    function comparable_cs(cs)
        key = "$(cs.name)-$(cs.version)-$(cs.archive_type)-$(triplet(cs.host))"
        if cs.target != nothing
            key *= "-$(triplet(cs.target))"
        end
        return key
    end
    for cs in sort(collect(keys(shard_hash_table)); by=comparable_cs)
        hash = shard_hash_table[cs]
        target = ""
        if cs.target != nothing
            target = "; target=$(repr(cs.target))"
        end
        teeln(fout, "    CompilerShard($(repr(cs.name)), $(repr(cs.version)), $(repr(cs.host)), $(repr(cs.archive_type))$(target))")
        teeln(fout, "      => $(repr(hash)),")
    end
    teeln(fout, ")")
end

mv(rht_path*".new", rht_path; force=true)
